# Avito Reviewer 

**Avito Reviewer** — это сервис, разработанный в рамках [тестового задания](https://github.com/avito-tech/tech-internship/blob/main/Tech%20Internships/Backend/Backend-trainee-assignment-autumn-2025/Backend-trainee-assignment-autumn-2025.md) для стажировки по Backend-направлению в компании Авито. Сервис предназначен для ля автоматического назначения ревьюверов на pull requests внутри команд разработки.

# Установка и запуск

1. **Клонирование репозитория**:

   ```bash
   git clone https://github.com/alexandrgurin25/avito-reviewer.git
   cd avito-reviewer
2. **Запуск с использованием Docker Compose**:
   ```bash
   make up
   ```

# Технические детали

## Стек технологий
- **Язык программирования:** Go
- **База данных:** PostgreSQL
- **Docker:** Используется для контейнеризации приложения
- **Postman:** Используется для проверки запросов
- **Migrate:** Для управления миграциями базы данных.
- **Zap:** Логирование.
- **Chi:** Роутер для HTTP сервера.
- **Cleanenv:** Для работы с переменными окружения.
- **K6:** Для проведения нагрузочного тестирования.

## Эндпоинты
### Основные
- `POST /team/add`: Создание новой команды с участниками.
- `GET /team/get`: Получение информации о команде и её участниках.
- `POST /users/setIsActive`: Изменение статуса активности пользователя.
- `GET /users/getReview`: Получение списка PR, где пользователь назначен ревьювером.
- `POST /pullRequest/create`: Создание PR с автоматическим назначением до 2 ревьюверов из команды автора.
- `POST /pullRequest/merge`: Пометить PR как MERGED (идемпотентная операция).
- `POST /pullRequest/reassign`: Переназначение конкретного ревьювера на другого активного пользователя из команды.
### Дополнительные
- `GET /stats/reviewers`: Получение статистики по количеству назначений ревьюверов каждому пользователю.
- `GET /health`: Проверка работы сервиса.


## Схема базы данных
<img width="1225" height="731" alt="image" src="https://github.com/user-attachments/assets/c190f782-f993-4314-a118-9477eff65eaa" />


   
# Пояснение

**1. Почему используем строковые ID вместо числовых?**

  - Клиент присылает готовые ID (ID пользователей, PR), а сервер их не генерирует.
  - Клиент присылает только team_name, но не готовый ID, поэтому только в этом случае генерируем ID

	В проекте используется гибридный подход к идентификаторам, основанный на практических соображениях и требованиях предметной области.
	Использование готовых ID от клиента там, где они уже существуют, уменьшает сложность. 
	Подход работает эффективно в рамках ожидаемых объемов данных (до 20 команд, до 200 пользователей).

 **2. В ручке `/team/add` создаем или обновляем команду и ее участников.**

  - Про обновление понял так, что если пользователь уже существует в другой команде, то он будет перемещен в новую команду.
	Хоть в функции AddTeam (internal/services/team_services/add_team.go) есть закомментированный блок, который проверял, что пользователь не принадлежит другой команде. 
	Но по заданию мы должны обновлять, но не сказано как конкретно, поэтому оставили так, что пользователь может быть перемещен. 

 **3. Почему в системе назначения ревьеверов используем рандомизацию ?**

 - Создаёт честное распределение нагрузки между активными ревьюерами, чтобы участники команды, которые имеют id выше остальных, не проверяли чаще других.

 **4. Использование ENUM для статусов Pull Reques. Почему выбрали ENUM вместо других подходов ?**
 
 - Ограничивает возможные значения статусов на уровне базы данных, предотвращая невалидные значения.
 - Улучшает производительность по сравнению с хранением строк, так как ENUM хранится как целое число, но представляется как строка.
 - Повышает читаемость запросов и данных, так как значения имеют понятные имена.

 **5. Явная проверка обязательных параметров**

 - В спецификации OpenAPI параметры `team_name` и `user_id` указаны как обязательные для соответствующих эндпоинтов
 - Без проверки при отсутствии параметров клиент получал бы пустой ответ. Так как это обязательные данные, решил их обработать и возвращать ошибку.

## Выполненные дополнительные задания: 

 - **Был добавлен эндпоинт *количество назначений ревьюверов каждому пользователю*.**
   
   `GET /stats/reviewers`
   
   Пример ответа по API
	 ```json
	{
	  "reviewer_stats": {
	    "u2": 5,
	    "u3": 2,
	    "u5": 1
	  }
	}
	
	```
- **Провел нагрузочное тестирование с целью проверить, соответствует ли она заявленным требованиям**
  В качестве системы нагрузочного тестирования использовался инструмент *k6*
  <img width="1543" height="1042" alt="image" src="https://github.com/user-attachments/assets/f4ea84b6-f64c-4ea0-b6a7-6c565193011c" />
		
	Результаты тестирования показали, что система не только соответствует, но и значительно превосходит требования.
	
	Ключевые метрики:
	Пропускная способность: 258 RPS (в 51 раз выше требуемых 5 RPS)
	Время ответа: 95-й перцентиль составляет 280.65 мс (укладывается в лимит 300 мс)
	Надежность: 100% запросов были успешными (из 108647 запросов только 10 неудачных, что составляет 0.009%)
	
	Система стабильно работала при 200 одновременных пользователях, обработав более 100 тысяч запросов без существенного роста времени ответа.
	
	**Вывод: система имеет значительный запас производительности и готова к эксплуатации в условиях, превышающих заявленные требования.**
	
	
	 Тестирование можно также провести у себя на устройстве. Для этого необходимо предварительно установить [K6](https://grafana.com/docs/k6/latest/set-up/install-k6/)
	 И воспользоваться командой
	 ```
	 make load-test
	 ```


- **Реализовал интеграционное и E2E-тестирование.**
  Можно проверить командой
  ```
  make test
  ```
	
- **Описал конфигурацию линтера.**
  Можно проверить командой
  ```
  make lint
  ```
